<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Drawing something on the screen - Amethyst 3D Tutorial</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title.html">Amethyst 3D Tutorial</a></li><li class="chapter-item expanded "><a href="empty-game.html"><strong aria-hidden="true">1.</strong> Creating an empty game</a></li><li class="chapter-item expanded "><a href="entity-and-component.html"><strong aria-hidden="true">2.</strong> Entity and Component</a></li><li class="chapter-item expanded "><a href="drawing-something-on-the-screen.html" class="active"><strong aria-hidden="true">3.</strong> Drawing something on the screen</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Amethyst 3D Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#drawing-something-on-the-screen" id="drawing-something-on-the-screen">Drawing something on the screen</a></h1>
<p>Alright, I think we're ready to try <em>actually drawing</em> something on the screen.</p>
<p>We're going to be using <a href="https://en.wikipedia.org/wiki/Physically_based_rendering">Physically based rendering</a> (PBR) for this game. It's pretty standard, and what other 3D engines (Unreal, Unity, Blender, etc) use to render stuff.</p>
<p>In PBR, you need three things at minimum to draw stuff:</p>
<ul>
<li>A camera to view the world from</li>
<li>Some objects to render</li>
<li>A light source (<em>technically</em> you don't need this, but everything will be 100% black if you don't)</li>
</ul>
<p>So, let's just go in that order. All three of these things will be represented by standard <strong>entities</strong>, with various different <strong>components</strong> attached to them.</p>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>Before we can set any of those things up, though, we need some place in our code to actually <em>initialize</em> those objects, so that Amethyst's ECS framework knows about them.</p>
<p>Amethyst states <a href="https://docs.rs/amethyst/0.8.0/amethyst/trait.State.html">have a few different methods</a> that run at different times and different intervals during the lifecycle of the state. Since we are forced to create an initial state to create an <code>Application</code>, we might as well use one of these methods to do the initialization work in.</p>
<p>Since we only need to initialize our three entities once per game, the <code>on_start</code> method seems like a good place to do this. <code>on_start</code> runs only once when we enter that state, which is exactly what we need.</p>
<pre><pre class="playground"><code class="language-rust">// (other includes)
use amethyst::StateData;
use amethyst::GameData;

struct GameState;
impl SimpleState for GameState {
    fn on_start(&amp;mut self, state_data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // More code will go here
    }
}

fn main() -&gt; amethyst::Result&lt;()&gt; {
    // (...)
}
</code></pre></pre>
<p>When Amethyst calls <code>on_start</code> (or any of the other methods), it passes in some &quot;state data&quot; that you can use for context into the rest of the game (see <a href="https://docs.rs/amethyst/0.8.0/amethyst/struct.StateData.html">StateData</a>). We don't really care about the lifetimes of the references inside the <code>StateData</code> for now, so we just use <code>'_</code> to tell Rust &quot;whatever you give us is fine with us&quot;.</p>
<p>Since we will ultimately want to create entities within our game (to create our camera, lights, and spaceship), we are mostly concerned with the <code>world</code> field within <code>StateData</code>; this is the same <code>world</code> that I mentioned at the end of the last chapter.</p>
<h2><a class="header" href="#creating-a-camera" id="creating-a-camera">Creating a camera</a></h2>
<p>The first step is to create a camera, which allows us to see all the objects we crate in our game.</p>
<p>To do this, we're going to use the <code>Camera</code> module from <code>renderer</code>.</p>
<p>Let's make a brand new function called <code>initialize_camera</code>:</p>
<pre><pre class="playground"><code class="language-rust">// (other includes)
use amethyst::prelude::World;
use amethyst::renderer::Camera;

// (GameState)
// (fn main)

fn initialize_camera(world: &amp;mut World) {
    world.create_entity()
        .with(Camera::standard_3d(1024.0, 768.0))
        .build();
}
</code></pre></pre>
<p>Since we're making a 3D game, we're going to use <code>standard_3d</code>.</p>
<p><code>1024.0</code> and <code>768.0</code> are just the dimensions of our window, which we defined in our <code>DisplayConfig</code>. You can refactor that into some constants if you like; I'll do some refactoring in an upcoming chapter.</p>
<p>The camera follows our standard <strong>entity</strong> and <strong>component</strong> setup I mentioned earlier:</p>
<ul>
<li>Create a nameless entity in our game world with <code>world.create_entity()</code></li>
<li>Add components to the entity; in this case, we're creating a <code>Camera</code> component and attaching it to this entity</li>
<li>Build the entity to finalize everything and actually add it to the world</li>
</ul>
<p>So the camera is <em>basically</em> the same as any other entity/component you're going to make in your game; the only difference is that <code>Camera</code> does some magic rendering-related stuff in the background.</p>
<p>Now, we need to hook that function up to our <code>on_start</code> method that we defined earlier:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_start(&amp;mut self, state_data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    initialize_camera(state_data.world);
}
<span class="boring">}
</span></code></pre></pre>
<p>If you <code>cargo run</code> that right now, you won't notice any difference. That's because we don't have any shapes for the camera to view! Let's make one now.</p>
<h2><a class="header" href="#creating-an-object-to-render" id="creating-an-object-to-render">Creating an object to render</a></h2>
<p>For now, we're just going to create a sphere so we understand what's going on. We'll modify it later to create the actual things in our game, like the spaceship and the cubes.</p>
<p>Like the camera, the sphere is also going to be a standard entity with components. Let's just follow the same pattern as we did with the camera to create it.</p>
<p>Create a new function called <code>initialize_sphere</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize_sphere(world: &amp;mut World) {
    world.create_entity()
        .with( /*???*/ )
        .build();
}
<span class="boring">}
</span></code></pre></pre>
<p>Call this function in <code>on_start</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_start(&amp;mut self, state_data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    initialize_camera(state_data.world);
    initialize_sphere(state_data.world);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to figure out how to give the sphere a &quot;shape&quot; to be rendered. In PBR, we need two things for our object to be renderable:</p>
<ul>
<li>A <strong>mesh</strong>, which gives our object a shape in 3D space</li>
<li>A <strong>material</strong>, which tells the rendering engine how to actually render that shape.</li>
</ul>
<p>In the next chapter I'll dive into these things with much more detail, but for now I'll just throw a blob of code at you.</p>
<h4><a class="header" href="#mesh" id="mesh">Mesh</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mesh = world.exec(|loader: AssetLoaderSystemData&lt;'_, Mesh&gt;| {
    loader.load_from_data(
        Shape::Sphere(100, 100)
            .generate::&lt;(Vec&lt;Position&gt;, Vec&lt;Normal&gt;, Vec&lt;Tangent&gt;, Vec&lt;TexCoord&gt;)&gt;(None)
            .into(),
        (),
    )
});
<span class="boring">}
</span></code></pre></pre>
<p>Here we're generating the sphere mesh with <code>Shape::Sphere(100, 100)</code>. There are <a href="https://docs.amethyst.rs/stable/amethyst_rendy/shape/enum.Shape.html">a few basic shape generators to choose from</a>, in case you want to mess around with your own shapes. The <code>100, 100</code> arguments are basically just the number of vertexes to generate the sphere with; more vertexes means a finer-&quot;resolution&quot; sphere. <code>100</code> is probably overkill, but it works for us.</p>
<h4><a class="header" href="#material" id="material">Material</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let material_defaults = world.read_resource::&lt;MaterialDefaults&gt;().0.clone();
let material = world.exec(|loader: AssetLoaderSystemData&lt;'_, Material&gt;| {
        loader.load_from_data(
            Material {
                ..material_defaults
            },
            (),
        )
    },
);
<span class="boring">}
</span></code></pre></pre>
<p>We're basically generating a default material. We'll learn about materials and play around with them in the next chapter.</p>
<h4><a class="header" href="#putting-it-all-together" id="putting-it-all-together">Putting it all together</a></h4>
<p>We have a mesh, and we have a material. They can both be treated as <strong>components</strong>, so we can simply add them to the entity.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.create_entity()
    .with(mesh)
    .with(material)
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>The full function should look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize_sphere(world: &amp;mut World) {
    let mesh = world.exec(|loader: AssetLoaderSystemData&lt;'_, Mesh&gt;| {
        loader.load_from_data(
            Shape::Sphere(100, 100)
                .generate::&lt;(Vec&lt;Position&gt;, Vec&lt;Normal&gt;, Vec&lt;Tangent&gt;, Vec&lt;TexCoord&gt;)&gt;(None)
                .into(),
            (),
        )
    });

    let material_defaults = world.read_resource::&lt;MaterialDefaults&gt;().0.clone();
    let material = world.exec(|loader: AssetLoaderSystemData&lt;'_, Material&gt;| {
        loader.load_from_data(
                Material {
                    ..material_defaults
                },
                (),
            )
        },
    );

    world.create_entity()
        .with(mesh)
        .with(material)
        .build();
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, we have a camera, and we have a renderable object. We don't have a light source yet, but we should still be able to see <em>some</em> shape, right? Let's <code>cargo run</code> the project and see what happens!</p>
<p><img src="images/blank-screen-camera-shape-same-location.png" alt="blank screen" /></p>
<p>Wait, what? Shouldn't we see a black sphere, at least?</p>
<p>The problem turns out to be that the camera is effectively spawned <em>inside</em> the sphere, which means it won't render the sphere. We need to move stuff around in our scene for things to make sense.</p>
<h2><a class="header" href="#transforms" id="transforms">Transforms</a></h2>
<p>To move stuff around, we're going to use the <code>TransformBundle</code>.</p>
<p>Let's add it to our <code>GameDataBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use amethyst::core::{Transform, TransformBundle};

let game_data = GameDataBuilder::default()
    .with_bundle(TransformBundle::new())?
    // other bundles
<span class="boring">}
</span></code></pre></pre>
<p>Now, let's move our camera back a little bit so we can see the outside of the sphere.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn initialize_camera(world: &amp;mut World) {
    let mut transform = Transform::default();
    transform.set_translation_xyz(0.0, 0.0, 10.0);

    world.create_entity()
        .with(Camera::standard_3d(1024.0, 768.0))
        .with(transform)
        .build();
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, the camera faces &quot;downwards&quot; in the negative Z direction. So if we move it &quot;upwards&quot; (positive Z) -- which is what we did with <code>set_translation_xyz</code> -- we should be able to see something sitting at <code>(0.0, 0.0, 0.0)</code>.</p>
<p>Transforms are treated as yet another <strong>component</strong>, so you can just attach them to your entity with <code>with()</code>.</p>
<p>Finally, let's make sure the sphere is sitting at <code>(0.0, 0.0, 0.0)</code>, and we should be able to see it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

let mut transform = Transform::default();
transform.set_translation_xyz(0.0, 0.0, 0.0);

world.create_entity()
    .with(mesh)
    .with(material)
    .with(transform)
    .build();
<span class="boring">}
</span></code></pre></pre>
<p><img src="images/black-sphere.png" alt="black sphere" /></p>
<p>Heeey, look at that. Pretty neat!</p>
<h2><a class="header" href="#create-a-light-source" id="create-a-light-source">Create a light source</a></h2>
<p>The final thing we need to do for a &quot;complete&quot; PBR system is create a light source. You can think of this as a lightbulb or the sun -- light is generated from the source, and scatters out from the source. When light hits an object like our sphere, it bounces off that object in a bunch of different directions. Some of that light bouncing off the object will bounce towards our camera. Then, the camera picks it up and renders what it sees for us on the screen. <em>(This is simplifying how things actually work in PBR quite a bit, but the concepts hold.)</em></p>
<p>The shape's material affects <em>how</em> the light bounces off of it. You can change a whole bunch of stuff about the material, and the results will be a wide variety of changes to how the shape is rendered on screen. We'll explore materials in the next chapter.</p>
<p>In our scene, the shape is blocking the background, so the renderer will draw <em>something</em> there. However, we don't have any light source to generate light to bounce off the shape, so the renderer will just render it as 100% black.</p>
<p>Our choice of a light blue clear color makes the scene above a little unintuitive: there's actually no &quot;light&quot; coming from the background, it's just what we draw if we have nothing else to render. It would make a little more sense if we chose a black clear color, but whatever; let's just create a light source and see what happens!</p>
<p>Like the camera and the sphere, the light source is just another ordinary <strong>entity</strong> with some <strong>components</strong> attached.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use amethyst::renderer::light::{Light, PointLight};
use amethyst::renderer::palette::rgb::Rgb;

fn initialize_light(world: &amp;mut World) {
    let light: Light = PointLight {
        intensity: 10.0,
        color: Rgb::new(1.0, 1.0, 1.0),
        ..PointLight::default()
    }.into();

    let mut transform = Transform::default();
    transform.set_translation_xyz(5.0, 5.0, 20.0);

    world
        .create_entity()
        .with(light)
        .with(transform)
        .build();
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Light</code> component is a PointLight, with intensity <code>10.0</code> and a completely white hue. We're moving the light behind the camera (<code>20.0</code> in the Z direction), and a little off-center.</p>
<p>Now, just add it to the game:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GameState;
impl SimpleState for GameState {
    fn on_start(&amp;mut self, state_data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        initialize_camera(state_data.world);
        initialize_sphere(state_data.world);
        initialize_light(state_data.world);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><img src="images/shaded-sphere.png" alt="shaded sphere" /></p>
<p>Now it actually <em>looks</em> like a sphere.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="entity-and-component.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="entity-and-component.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
